---
title: "scRNAseq Markers and Cell annotation"
author: "Me!"
date: "`r Sys.Date()`"
output: html_document
---

# 0 - Project Setup

## Load packages

```{r}
library(EnhancedVolcano)
library(harmony)
library(here)
library(Seurat)
library(tidyverse)
set.seed(43)
source(here("05_multi-sample/05-helper_functions.R"))
```

## Downloading the necessary files

Make sure that you've downloaded a zip of the github repo https://github.com/yerkes-gencore/scRNAseqWorkshop2023 and unzip it somewhere on your computer (e.g. in your `Desktop` directory).

If you want to keep working in the directory you created last class, simple copy and paste the `05_multi-sample` folder into the base level of your existing directory.

If you'd like to start fresh in a clean working directory, you can simply work from the newly unzipped folder.

*Note: If you are comfortable using git (beyond the scope of this workshop) and are already working within a local clone of the repo, you can skip the above and simply `git pull` the repo.*

## Read in processed objects

We'll start working with objects in lists, since we may have many captures we need to integrate.
Recall that each capture should be processed independently, so it should probably be it's own object.

```{r}
objs <- list()
objs$s101_stim <- readRDS(here('saved_rds/04/s101_stim_annotated.rds'))
objs$s101_ctrl <- readRDS(here('saved_rds/04/s101_ctrl_annotated.rds'))

objs$s1488_stim <- readRDS(here('saved_rds/04/s1488_stim_annotated.rds'))
objs$s1488_ctrl <- readRDS(here('saved_rds/04/s1488_ctrl_annotated.rds'))

objs$s1016_stim <- readRDS(here('saved_rds/04/s1016_stim_annotated.rds'))
objs$s1016_ctrl <- readRDS(here('saved_rds/04/s1016_ctrl_annotated.rds'))
```

We can now use the 'apply()' family of functions to perform operations on 
every object in the list. 

```{r}
## See the documentation on the apply family for more details on implementation
## ?apply
lapply(objs, DimPlot, group.by = 'seurat_clusters')
```

Recall that UMAP space is arbitrary and specific to a capture. Comparing
the relative position of similar celltypes between captures is uninformative
at this stage. 

```{r}
lapply(objs, DimPlot)
```

# 1 - Working with multiple captures

## Merging objects

We will start by merging our objects into one object. We also add a metadata
column so each cell is tagged with it's original capture. With this information,
we can always split the captures back out, and we can see the success of our 
integration. 

```{r}
## adding metadata based on the names we gave the objects when loading them
for (capture.ID in names(objs)){
  objs[[capture.ID]]$capID <- capture.ID
}
## Seurat extends the base merge() function to work on lists of Seurat objects
## Adding cell IDs prevents possible collisions in barcodes across captures
merged_obj <- merge(objs[[1]], y = objs[2:length(objs)], add.cell.ids = names(objs))
```

Our merged object should now have all the cells and genes from the split objects

```{r}
lapply(objs, dim)

print('merged_obj')
dim(merged_obj)
```

We want to identify shared populations of cells between captures and analyze
changes in expression for similar populations. However, simply merging captures 
is often insufficient to analyze them together. Variation between captures is 
often stronger than variation between celltypes, causing merged objects to 
cluster by capture or condition rather than shared celltypes.

```{r}
## We use a piped (%>%) workflow to quickly apply many functions to the same object
## without needing to write the object out between each step, slightly improving efficiency
merged_obj <- NormalizeData(merged_obj, normalization.method = 'LogNormalize') %>%
  ScaleData() %>%
  FindVariableFeatures(selection.method = "vst", nfeatures = 2000) %>%
  RunPCA(npcs = 50) %>%
  FindNeighbors(dims = 1:30) %>%
  RunUMAP(dims = 1:30) %>%
  FindClusters()
```

Look at the clusters in the merged object. Are cells from multiple captures
blending seamlessly within captures? 

```{r, fig.width=12, fig.height=6}
DimPlot(merged_obj, group.by = 'capID') + DimPlot(merged_obj, group.by = 'consensus_labels')
```

```{r, fig.width=12}
DimPlot(merged_obj, split.by = 'capID', ncol = 3)
```

If not, time to integrate

## Seurat integration

Recreating the list of separate captures from our merged object. This has the
benefit of retaining the modified cell barcodes and added metadata from creating
the merged object.

```{r}
objs <- SplitObject(merged_obj, split.by = 'capID')
```

Choose which features to use when integrating

```{r}
anchor_features <- SelectIntegrationFeatures(objs)
## This is just a list of genes
head(anchor_features)
```

Now identify integration anchors

```{r}
integration_anchors <- FindIntegrationAnchors(objs,
                                              anchor.features = anchor_features,
                                              scale = FALSE,
                                              normalization.method = 'LogNormalize',
                                              reduction = 'rpca',
                                              dims = 1:30)
```

```{r}
seurat_integrated_obj <- IntegrateData(anchorset = integration_anchors,
                                normalization.method = 'LogNormalize')
```

```{r}
seurat_integrated_obj <- seurat_integrated_obj %>%
  ScaleData() %>%
  RunPCA() %>%
  RunUMAP(dims = 1:30) %>%
  FindNeighbors(dims = 1:30) %>%
  FindClusters()
```

How does this compare to merging? Do we see more overlap of captures?

```{r, fig.height=6, fig.width=12}
DimPlot(seurat_integrated_obj, group.by = 'capID') + DimPlot(seurat_integrated_obj, group.by = 'consensus_labels')
```


```{r, fig.width=12}
DimPlot(seurat_integrated_obj, split.by = 'capID', ncol = 3)
```

## Harmony integration

```{r}
harmony_integrated_obj <- RunHarmony(
  merged_obj,
  group.by.vars = 'capID',
  reduction.save = 'harmony',
  max_iter = 20
)
```

```{r}
harmony_integrated_obj
harmony_integrated_obj@reductions$harmony[1:5,1:5]
dim(harmony_integrated_obj@reductions$harmony)
```

Similar to PCA, harmony reduction gives us many dimensions. We'll need to run
UMAP to make a good 2d visualization.

```{r}
harmony_integrated_obj <- RunUMAP(harmony_integrated_obj, reduction = 'harmony', dims = 1:30) %>%
  FindNeighbors(reduction = 'harmony', dims = 1:30) %>%
  FindClusters()
```

How does this compare to Seurat integration? How does it compare to merging?

```{r, fig.width=12, fig.height=6}
DimPlot(harmony_integrated_obj, group.by = 'capID') + 
  DimPlot(harmony_integrated_obj, group.by = 'consensus_labels') 
```

```{r, fig.width=12}
DimPlot(harmony_integrated_obj, split.by = 'capID', ncol = 3)
```


## Choose a method to move forward with

Which technique looked best to you? Select one to move forward with. 
You can remove the others from your environment if memory use is a concern.

```{r}
obj <- ??? ## chose one of merged_object, seurat_integrated_obj, or harmony_integrated_obj
## Optional, remove the other objects from your environment, e.g.:
## rm(unwanted_obj)
```

## Assign integrated cluster identities

In practice, you should use the workflow from the previous session to thoroughly
evaluate markers and assign celltypes. Here we will use a truncated workflow
to quickly gloss over this and get to differential expression.

```{r}
DimPlot(obj, label = TRUE)
```


```{r, fig.width = 9, fig.height = 10, warning = FALSE}
plotRefMapScoresFacet(obj, label_column = "SingleR_pruned.labels", 
                      label_score_column = "SingleR_delta.next", 
                      clusters_column = "seurat_clusters")
```

```{r}
obj$consensus_labels <- obj$seurat_clusters
Idents(obj) <- "consensus_labels"

obj <- RenameIdents(
  obj,
  "0" = "t cells",
  "1" = "monocytes",
  "2" = "t cells",
  "3" = "t cells",
  "4" = "b cells",
  "5" = "t cells",
  "6" = "NK cells",
  "7" = "monocytes",
  "8" = "Unknown",
  "9" = "b cells",
  "10" = "b cells",
  "11" = "Unknown",
  "12" = "Unknown",
  "13" = "Dendritic cells"
)
obj$consensus_labels <- Idents(obj)
```

```{r}
DimPlot(obj, group.by = 'consensus_labels', label = TRUE)
```


# 2 - Differential expression

Now that we have our captures successfully integrated/merged and we've identified
shared cell populations, we can perform differential expression across conditions.

First, we'll add metadata for our conditions in case it hasn't already been
added.

```{r}
## We can just take the end of the capID 
obj$condition <- stringr::str_sub(obj$capID, start = -4)
```

Then run Seurat's FindMarkers, focusing on a specific cluster and the comparison
of ctrl and stim cells in that cluster

```{r}
cluster_dge <- FindMarkers(obj,
                           group.by = 'condition',
                           ident.1 = 'stim',
                           ident.2 = 'ctrl',
                           subset.ident = 'NK cells', ## Chose an Ident here
                           test.use = 'wilcox',
                           logfc.threshold = 0.0,
                           min.pct = .1,
                           only.pos = FALSE,
                           assay = 'RNA')
```

DGE is calculated where a positive log-fold change (LFC) indicates greater expression 
in ident.1, and a gene with negative LFC is more highly expressed in ident.2.

```{r}
cluster_dge
```

## Violin plots

It's a good idea to visualize the observed values to see if they match what you
can visibly detect.

```{r, fig.width=10}
VlnPlot(obj, features = head(rownames(cluster_dge),3),
        group.by = 'seurat_clusters', split.by = 'condition',
        ncol = 1)
```

Seurat's violin plot function is a little limited, so we have a custom function
to focus on the cells of interest (see the helper script for more details).

```{r, fig.height=4, warning = FALSE}
gcoreVlnPlot(obj, 
             genes = head(rownames(cluster_dge),3),
             subset = '5', 
             grouping_var = 'condition', groups = c('ctrl', 'stim'),
             filter_zeros = FALSE)
```

## Volcano plto

Volcano plots are a popular visualization to show an overview of transcriptional
change between states. Lots of activity in the upper left and right quadrants 
suggest strong change.

```{r, fig.width=8, fig.height=6}
## See helper functions script for more details 
generateVolcanoPlot(cluster_dge, labels = 20, pCutoff = 0.05, FCcutoff = log2(1.3))
```

# 3 - GSEA: Gene set enrichment analysis

Gene Set Enrichment Analysis (GSEA) is a computational method that determines 
whether an a priori defined set of genes shows statistically significant,
concordant differences between two biological states (e.g. phenotypes). 
GSEA takes a list of genes ranked by some metric (often the 
magnitude/significance, and direction of differential expression between two 
groups) and a set of pathway definitions. Enrichment can be loosely interpreted 
as collective up or down regulation of a pathway. Pathways can be any set of 
genes, including custom ones for your study. We often uses genesets from the 
[Molecular Signatures Database](https://www.gsea-msigdb.org/gsea/msigdb/index.jsp).
For GSEA performed on differential expression outputs, a positive enrichment 
score indiciates the pathway is enriched in the first group
of a differential expression comparison, while a negative enrichment score means
the pathway is enriched in the second group.

For example, if differentially expressed genes are calculated between a 
'treatment' and 'control' group, where positive log-fold change
indicates the gene is more highly expressed in the 'treatment' group, a 
positive enrichment score means the pathway is enriched in the 'treatment' group. 

You can read more details on GSEA [here](https://www.pnas.org/doi/10.1073/pnas.0506580102)

```{r}
## Installing and loading packages
if (!require('fgsea')) {
  BiocManager::install('fgsea')
}
library(fgsea)

if (!require('msigdbr')) {
  install.packages('msigdbr')
}
library(msigdbr)
```

```{r}
## you can see more available datasets on the website, or via the command:
## msigdbr::msigdbr_collections()
## Some collections are available for other species, see the command:
## msigdbr::msigdbr_species()
hallmark_pathways <- msigdbr(species = "human", category = "H")
hallmark_pathways <- hallmark_pathways %>% 
  select(gene_symbol, gs_name) %>%
  unstack()
hallmark_pathways$HALLMARK_INFLAMMATORY_RESPONSE
```

```{r}
prepare_gsea_stats <- function(dge_result){
  ## Why +.Machine$double.xmin? Some p-values are below the smallest possible 
  ## value in R, which R rounds to 0, which causes some issues with calculations.
  ## We add the smallest possible value to all p-values to make them non-zero.
  stat <- dge_result$avg_log2FC * -log10(dge_result$p_val_adj + .Machine$double.xmin)
  ## There are differing opinions on the best stat to use for GSEA with single-cell
  ## data. Another approach is to use only the logFC value, which assumes some
  ## shrinkage due to the estimated significance. However, seurat's base
  ## fold-change calculation is pretty rudimentary, and this approach should
  ## help weight genes based on the consistency of differential expression. 
  stat <- setNames(stat, nm = rownames(dge_result))
  ## GSEA expects a named sorted list
  stat <- sort(stat)
  stat
}
```

```{r}
gsea_results <- fgsea::fgseaSimple(pathways = hallmark_pathways, 
                                   stats = prepare_gsea_stats(cluster_dge),
                                   nperm = 1000)
```

```{r}
arrange(gsea_results, pval)
```

