---
title: "scRNAseq Markers and Cell annotation"
author: "Me!"
date: "`r Sys.Date()`"
output: html_document
---

# 0 - Project Setup

## Load packages

```{r}
library(EnhancedVolcano)
library(harmony)
library(here)
library(Seurat)
library(tidyverse)

source(here("05_multi-sample/05-helper_functions.R"))
```

## Downloading the necessary files

Make sure that you've downloaded a zip of the github repo https://github.com/yerkes-gencore/scRNAseqWorkshop2023 and unzip it somewhere on your computer (e.g. in your `Desktop` directory).

If you want to keep working in the directory you created last class, simple copy and paste the `05_multi-sample` folder into the base level of your existing directory.

If you'd like to start fresh in a clean working directory, you can simply work from the newly unzipped folder.

*Note: If you are comfortable using git (beyond the scope of this workshop) and are already working within a local clone of the repo, you can skip the above and simply `git pull` the repo.*

## Read in processed objects

We'll start working with objects in lists, since we may have many captures we need to integrate.
Recall that each capture should be processed independently, so it should probably be it's own object.

```{r}
objs <- list()
objs$s101_stim <- readRDS(here('saved_rds/04/s101_stim_annotated.rds'))
objs$s101_ctrl <- readRDS(here('saved_rds/04/s101_ctrl_annotated.rds'))

objs$s1488_stim <- readRDS(here('saved_rds/04/s1488_stim_annotated.rds'))
objs$s1488_ctrl <- readRDS(here('saved_rds/04/s1488_ctrl_annotated.rds'))

objs$s1016_stim <- readRDS(here('saved_rds/04/s1016_stim_annotated.rds'))
objs$s1016_ctrl <- readRDS(here('saved_rds/04/s1016_ctrl_annotated.rds'))
```

We can now use the 'apply()' family of functions to perform operations on 
every object in the list. 

```{r}
## See the documentation on the apply family for more details on implementation
## ?apply
lapply(objs, DimPlot, group.by = 'seurat_clusters')
```

Recall that UMAP space is arbitrary and specific to a capture. Comparing
the relative position of similar celltypes between captures is uninformative
at this stage. 

```{r}
lapply(objs, DimPlot)
```

# 1 - Working with multiple captures

## Merging objects

We will start by merging our objects into one object. We also add a metadata
column so each cell is tagged with it's original capture. With this information,
we can always split the objects back out, and we can see the success of our 
integration. 

```{r}
## adding metadata based on the names we gave the objects when loading them
for (capture.ID in names(objs)){
  objs[[capture.ID]]$capID <- capture.ID
}
## Seurat extends the base merge() function to work on lists of Seurat objects
## Adding cell IDs prevents possible collisions in barcodes across captures
merged_obj <- merge(objs[[1]], y = objs[2:length(objs)], add.cell.ids = names(objs))
```

Our merged object should now have all the cells and genes from the split objects

```{r}
lapply(objs, dim)

print('merged_obj')
dim(merged_obj)
```

However, simply merging captures is often insufficient to analyze them together.
Variation between captures is often stronger than variation between celltypes, 
causing merged objects to cluster by original capture rather than shared celltypes.

```{r}
## We use a piped (%>%) workflow to quickly apply many functions to the same object
## without needing to write the object out between each step, slightly improving efficiency
merged_obj <- NormalizeData(merged_obj, normalization.method = 'LogNormalize') %>%
  ScaleData() %>%
  FindVariableFeatures(selection.method = "vst", nfeatures = 2000) %>%
  RunPCA(npcs = 50) %>%
  FindNeighbors(dims = 1:30) %>%
  RunUMAP(dims = 1:30) %>%
  FindClusters()
```

Are similar celltypes clustering together across captures?

```{r, fig.width=12, fig.height=6}
DimPlot(merged_obj, group.by = 'capID') + DimPlot(merged_obj, group.by = 'consensus_labels')
```

```{r, fig.width=12}
DimPlot(merged_obj, split.by = 'capID', ncol = 3)
```



If not, time to integrate

## Seurat integration

Recreating the list of separate captures. This has the benefit of retaining 
the modified cell barcodes and added metadata from creating the merged object

```{r}
objs <- SplitObject(merged_obj, split.by = 'capID')
```

Choose which features to use when integrating

```{r}
anchor_features <- SelectIntegrationFeatures(objs)
## This is just a list of genes
head(anchor_features)
```

Now identify integration anchors

```{r}
integration_anchors <- FindIntegrationAnchors(objs,
                                              anchor.features = anchor_features,
                                              scale = FALSE,
                                              normalization.method = 'LogNormalize',
                                              reduction = 'rpca',
                                              dims = 1:30)
```

```{r}
seurat_integrated_obj <- IntegrateData(anchorset = integration_anchors,
                                normalization.method = 'LogNormalize')
```

```{r}
seurat_integrated_obj <- seurat_integrated_obj %>%
  ScaleData() %>%
  RunPCA() %>%
  RunUMAP(dims = 1:30) %>%
  FindNeighbors(dims = 1:30) %>%
  FindClusters()
```

How does this compare to merging? Do we see more overlap of captures?

```{r, fig.height=6, fig.width=12}
DimPlot(seurat_integrated_obj, group.by = 'capID') + DimPlot(seurat_integrated_obj, group.by = 'consensus_labels')
```


```{r, fig.width=12}
DimPlot(seurat_integrated_obj, split.by = 'capID', ncol = 3)
```

## Harmony integration

```{r}
harmony_integrated_obj <- RunHarmony(
  merged_obj,
  group.by.vars = 'capID',
  reduction.save = 'harmony',
  max_iter = 20
)
```

```{r}
harmony_integrated_obj
harmony_integrated_obj@reductions$harmony[1:5,1:5]
dim(harmony_integrated_obj@reductions$harmony)
```

Similar to PCA, harmony reduction gives us many dimensions. We'll need to run
UMAP to make a good 2d visualization.

```{r}
harmony_integrated_obj <- RunUMAP(harmony_integrated_obj, reduction = 'harmony', dims = 1:30) %>%
  FindNeighbors(reduction = 'harmony', dims = 1:30) %>%
  FindClusters()
```

How does this compare to Seurat integration? How does it compare to merging?

```{r, fig.width=12, fig.height=6}
DimPlot(harmony_integrated_obj, group.by = 'capID') + 
  DimPlot(harmony_integrated_obj, group.by = 'consensus_labels') 
```

```{r, fig.width=12}
DimPlot(harmony_integrated_obj, split.by = 'capID', ncol = 3)
```


## Choose a method to move forward with

Which technique looked best to you? Select one to move forward with. 
You can remove the others from your environment if memory use is a concern.

```{r}
obj <- ??? ## chose one of merged_object, seurat_integrated_obj, or harmony_integrated_obj
## Optional, remove the other objects from your environment, e.g.:
## rm(unwanted_obj)
```


# 2 - Differential expression

Now that we have our captures successfully integrated/merged, we can identify
shared populations between our captures and perform differential expression
between conditions.

First, we'll add metadata for our conditions in case it hasn't already been
added.

```{r}
## We can just take the end of the capID 
obj$condition <- substr(obj$capID, start = 6, stop = 9)
```

Then run Seurat's FindMarkers, focusing on a specific cluster and the comparison
of ctrl and stim cells in that cluster

```{r}
cluster_dge <- FindMarkers(obj,
                           group.by = 'condition',
                           ident.1 = 'stim',
                           ident.2 = 'ctrl',
                           subset.ident = '5', ## Chose a cluster here, e.g. 1
                           test.use = 'wilcox',
                           logfc.threshold = 0.0,
                           min.pct = .1,
                           only.pos = FALSE,
                           assay = 'RNA')
```

DGE is calculated where a positive log-fold change (LFC) indicates greater expression 
in ident.1, and a gene with negative LFC is more highly expressed in ident.2.

```{r}
cluster_dge
```

## Violin plots

It's a good idea to visualize the observed values to see if they match what you
can visibly detect.

```{r, fig.width=10, warning = FALSE}
VlnPlot(obj, features = head(rownames(cluster_dge),3),
        group.by = 'seurat_clusters', split.by = 'condition')

## Seurat's violin plot function is a little limited, so we have a custom function
## to focus on the cells of interest (see the helper script for more details).

gcoreVlnPlot(obj, 
             genes = head(rownames(cluster_dge),3),
             subset = '5', 
             grouping_var = 'condition', groups = c('ctrl', 'stim'),
             filter_zeros = FALSE)
```

## Volcano plto

Volcano plots are a popular visualization to show an overview of transcriptional
change between states. Lots of activity in the upper left and right quadrants 
suggest strong change.

```{r, fig.width=8, fig.height=6}
## See helper functions script for more details 
generateVolcanoPlot(cluster_dge, labels = 20, pCutoff = 0.05, FCcutoff = log2(1.3))
```



