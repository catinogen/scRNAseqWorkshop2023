---
title: "scRNAseq QC and Processing"
author: "Me!"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
library(Seurat)
library(tidyverse)
library(here)
library(clustree)
library(scDblFinder)
knitr::opts_chunk$set(echo=FALSE,
                      warning=TRUE,
                      message=TRUE,
                      include=TRUE,
                      fig.width = 8, fig.height = 8,
                      fig.align = 'center',
                      cache=FALSE, cache.lazy = FALSE)
## Explicitly setting the randomizer seed for reproducibility 
set.seed(43)
## Sourcing a small set of custom functions as a separate script to keep this
## script shorter and more readable
source(here('R/functions_session-02.R'))
```

# Load data

```{r}
## Reading in CellRanger outputs
obj <- Read10X_h5(here('Data/infected/C141/GSM4339769_C141_filtered_feature_bc_matrix.h5'))
obj <- CreateSeuratObject(obj)

## Initializing a list to record changes to our dataset through processing steps
qc_receipts <- list()
qc_receipts$raw_data <- dim(obj)
```

# Add QC metrics

```{r}
# Add number of genes per UMI for each cell to metadata
obj$log10GenesPerUMI <- log10(obj$nFeature_RNA)/log10(obj$nCount_RNA)

# Mitochondrial ratio
obj$percent.mt <- Seurat::PercentageFeatureSet(object=obj, pattern="^MT")/100

# Ribosomal ratio
obj$percent.rb <- Seurat::PercentageFeatureSet(object=obj, pattern="^RP[SL]")/100
```

```{r}
VlnPlot(obj, features = c('nFeature_RNA', 'nCount_RNA', 'percent.mt'), ncol = 3)
```

```{r}
plot1 <-FeatureScatter(obj, feature1 = "nCount_RNA", feature2 = "percent.mt") + 
  aes(alpha = 0.5) + 
  NoLegend()
plot2 <- FeatureScatter(obj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") + 
  aes(alpha = 0.5) + 
  NoLegend()
plot1 + plot2
```

```{r}
ggplot(obj@meta.data, aes(x=log10GenesPerUMI, y=nCount_RNA, color=percent.mt)) +
  geom_point(alpha=0.2) +
  scale_color_gradient(low = 'goldenrod1', high = 'red', limits = c(0,1)) +
  scale_x_log10() +
  scale_y_log10() +
  theme_classic()
```

# Identify doublets

This method uses [scDblFinder](https://plger.github.io/scDblFinder/index.html).
Other packages such as [DoubletFinder](https://github.com/chris-mcginnis-ucsf/DoubletFinder)
perform similar processing.

```{r}
## Custom function, see 'R/functions_session-02.R' for more details
obj <- run_scDblFinder(obj)
```

```{r}
obj <- subset(obj, subset = scDblFinder.class == 'singlet')
qc_receipts$post_doublet_removal <- dim(obj)
```

# Filtering low quality cells

## Set filtering thresholds

Using an outlier detection approach to initialize QC cutoff thresholds. 
You could also manually specify your filtering thresholds. Reasonable
cutoffs depend on the source material and study goals, so tailor
these as necessary. 

```{r}
## Custom function, see 'R/functions_session-02.R' for more details
## nmads = number of median absolute devations used for outlier threshold
cutoffs <- generate_capture_QC_cutoffs(obj, nmads = 5)
cutoffs
```

The function caps lower bounds at 0, but functionally, we want to set
some minimum thresholds. GEMs/cells with very few reads confound the analysis
as they are difficult to cluster. 

```{r}
cutoffs$nCount_RNA.min <- 2500
cutoffs$nFeature_RNA.min <- 200
## This particular dataset is heavy with low-count cells, dragging the 
## threshold's upper bound down. I'm manually setting it higher to include
## Cells that seem reasonably within range of the dataset
cutoffs$nCount_RNA.max <- 45000
```

Now adding metadata to identify which cells fall within thresholds

```{r}
obj$filtered <- 
  !(obj$nCount_RNA >= cutoffs$nCount_RNA.min &
    obj$nCount_RNA <= cutoffs$nCount_RNA.max &
    obj$nFeature_RNA >= cutoffs$nFeature_RNA.min &
    obj$nFeature_RNA <= cutoffs$nFeature_RNA.max &
    obj$log10GenesPerUMI >= cutoffs$log10GenesPerUMI.min &
    obj$log10GenesPerUMI <= cutoffs$log10GenesPerUMI.max &
    obj$percent.mt >= cutoffs$percent.mt.min &
    obj$percent.mt <= cutoffs$percent.mt.max &
    obj$percent.rb >= cutoffs$percent.rb.min &
    obj$percent.rb <= cutoffs$percent.rb.max)
```


```{r}
ggplot(obj@meta.data, aes(x=nCount_RNA, y=nFeature_RNA, color=filtered)) +
  geom_point(alpha=0.2) +
  scale_color_manual(values = c('grey', 'orange')) +
  #stat_smooth(method=lm) +
  scale_x_log10() +
  scale_y_log10() +
  theme_classic()
```

```{r}
VlnPlot(obj, features = c('nFeature_RNA', 'nCount_RNA', 'percent.mt'), ncol = 3,
        group.by = 'filtered') 
```

## Filter cells

```{r}
obj <- subset(obj, subset = filtered == FALSE)
qc_receipts$post_filtering <- dim(obj)
```

# QC filtering summary

```{r}
qc_receipts
```


# Normalize and scale

```{r}
obj <- NormalizeData(obj, normalization.method = 'LogNormalize')
obj <- ScaleData(obj)
```

# Dimensional reduction

## Find variable features

```{r}
obj <- FindVariableFeatures(obj)
```

## Calculate PCs

```{r}
obj <- RunPCA(obj)
```

## Identify relevant PCs

```{}
Don't get too hung up on this: most of the state-of-the-field methods
are pretty robust to PC selection. The most important point is to 
include all of the most high-variance PCs.
```


```{r}
ElbowPlot(obj, ndims = 30)
```

```{r}
obj <- FindNeighbors(obj, dims = 1:20)
```

## Calculating UMAP

```{r}
obj <- RunUMAP(obj, dims = 1:20)
```

```{r}
DimPlot(obj, group.by = 'orig.ident')
```


## Selecting clustering resolution

```{r}
## Making a temporary copy of the object so we don't have all this
## unneeded data in our working object
clustree_data <- obj
for (i in seq(0.2,1.4,0.1)){
  clustree_data <- FindClusters(clustree_data, resolution = i, verbose = FALSE)
}
```


```{r, fig.height=12, fig.width=12}
clustree(clustree_data)
```

```{r}
obj <- FindClusters(obj, resolution = 1.3)
```

```{r}
DimPlot(obj, label = TRUE)
```



# Capture level metadata clustering

```{r, fig.width=12, fig.height=12}
FeaturePlot(obj,
            features = c('nFeature_RNA',
                         'nCount_RNA',
                         'percent.mt',
                         'percent.rb', 
                         'log10GenesPerUMI',
                         'CD3G'))
```

# Check cell cycle

See if any CC genes are in your variable features. 
If not, you probably don't need to do this

```{r}
c(cc.genes$s.genes, cc.genes$g2m.genes)[c(cc.genes$s.genes, cc.genes$g2m.genes) %in% VariableFeatures(obj)]
```

It's also useful to look at your final clustering to see if it's actually
being driven by cell cycle. Look for separation of phases. 

```{r}
## Seurat has functions to calculate a module score, weighting
## the expression of many genes into a single value. 
## Seurat provides a list of cell-cycle associated genes that we pass
## to their function. The output includes cell cycle scores 
## and a single phase classification.
obj <- CellCycleScoring(obj,
                        s.features = cc.genes$s.genes,
                        g2m.features = cc.genes$g2m.genes)
DimPlot(obj, group.by = 'Phase')
```

If you see something that looks like it's being driven by cell cycle,
you can attempt to regress the expression signature associated with cell cycle
out from your data.

To quickly inspect if cell cycle regression will be fruitful, 
we will focus on the subset of genes present in more than N cells. 

```{r}
## Custom function, see 'R/functions_session-02.R' for more details
obj.cc_check <- filterLowGenes(obj, min.cells = 100, assay = 'RNA', calculate_only = FALSE)
```

```{r}
obj.cc_check <- ScaleData(obj.cc_check,
                          vars.to.regress = c('S.Score', 'G2M.Score'),
                          features = rownames(obj.cc_check)) %>%
  FindVariableFeatures() %>%
  RunPCA() %>%
  FindNeighbors(dims = 1:20) %>%
  RunUMAP(dims = 1:20)
  
DimPlot(obj.cc_check, reduction = 'umap', group.by = 'Phase')
```

If this doesn't look like an improvement, but you still want to regress cell cycle
from the data, you can try an alternative workflow

```{r}
obj.cc_check$CC.difference <- obj.cc_check$S.Score - obj.cc_check$G2M.Score

obj.cc_diff_check <- ScaleData(obj.cc_check,
                          vars.to.regress = c('CC.difference'),
                          features = rownames(obj.cc_check)) %>%
  FindVariableFeatures() %>%
  RunPCA() %>%
  FindNeighbors(dims = 1:20) %>%
  RunUMAP(dims = 1:20)
  
DimPlot(obj.cc_diff_check, reduction = 'umap', group.by = 'Phase')
```


# Save processed object

```{r}
saveRDS(obj, here('saved_rds/processed_obj.Rds'))
```

